<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://pizssn.github.io</id>
    <title>pizssn</title>
    <updated>2020-05-27T10:09:23.694Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://pizssn.github.io"/>
    <link rel="self" href="https://pizssn.github.io/atom.xml"/>
    <subtitle>一名沉浮在代码世界的游荡者</subtitle>
    <logo>https://pizssn.github.io/images/avatar.png</logo>
    <icon>https://pizssn.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, pizssn</rights>
    <entry>
        <title type="html"><![CDATA[线程方法学习]]></title>
        <id>https://pizssn.github.io/post/xian-cheng-fang-fa-xue-xi/</id>
        <link href="https://pizssn.github.io/post/xian-cheng-fang-fa-xue-xi/">
        </link>
        <updated>2019-11-25T12:07:04.000Z</updated>
        <content type="html"><![CDATA[<p>  列举了几个线程常用方法。</p>
<h2 id="线程停止">线程停止</h2>
<ol>
<li>建议线程正常停止，利用次数，不建议死循环</li>
<li>建议使用标志位，设置一个标志位</li>
<li>不要使用stop或者destroy等过时或JDK不建议使用的法</li>
</ol>
<pre><code class="language-java">public class Demo1 implements Runnable {
    //设置一个标识位
    private boolean flag = true;

    @Override
    public void run() {
        int i = 0;
        while (flag) {
            System.out.println(&quot;run...Thread&quot; + i++);
        }
    }

    //设置一个公开的方法停止线程，转换标志位
    public void stop() {
        this.flag = false;
    }

    public static void main(String[] args) {
        Demo1 d = new Demo1();
        new Thread(d).start();
        for (int i = 0; i &lt; 10000; i++) {
            System.out.println(&quot;main&quot; + i);
            if (i == 9000) {
                //调用stop方法切换标志位，让线程停止
                d.stop();
                System.out.println(&quot;该线程停止&quot;);
            }
        }
    }
}
</code></pre>
<h2 id="线程休眠">线程休眠</h2>
<p>  sleep() 的作用是让当前线程休眠，即当前线程会从“运行状态”进入到“休眠(阻塞)状态”。sleep()会指定休眠时间，线程休眠的时间会大于/等于该休眠时间；在线程重新被唤醒时，它会由“阻塞状态”变成“就绪状态”，从而等待cpu的调度执行。<br>
  <strong>注意：</strong><code>sleep()</code>和<code>wait()</code>是有区别的。wait()的作用是让当前线程由“运行状态”进入“等待(阻塞)状态”的同时，也会释放同步锁。而sleep()的作用是也是让当前线程由“运行状态”进入到“休眠(阻塞)状态”。但是，<mark>wait()会释放对象的同步锁，而sleep()则不会释放锁。</mark></p>
<pre><code class="language-java">import java.text.SimpleDateFormat;
import java.util.Date;

//sleep的功能
public class Demo2 {

    public static void main(String[] args) throws InterruptedException {
        //打印当前系统时间
        Date currentTime = new Date();//获取系统当前时间
        while (true) {
            try {
                Thread.sleep(1000);
                System.out.println(new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(currentTime));
                currentTime = new Date();//刷新系统当前时间
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

    }
    public static void TimeDown(int num) throws InterruptedException {
        //模拟倒计时的功能
        while (true) {
            Thread.sleep(1000);
            System.out.println(num--);
            if (num &lt; 0)
                break;
        }
    }
}
</code></pre>
<h2 id="线程礼让">线程礼让</h2>
<p>  只是让原来已经执行的线程先退出来重新竞争资源，还是得看CPU分配。</p>
<pre><code class="language-java">public class Demo3 {
    public static void main(String[] args) {
        MyYield m = new MyYield();
        new Thread(m, &quot;a&quot;).start();
        new Thread(m, &quot;b&quot;).start();
        new Thread(m, &quot;c&quot;).start();
    }
}

class MyYield implements Runnable {
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + &quot;线程开始执行&quot;);
        Thread.yield();//线程礼让
        System.out.println(Thread.currentThread().getName() + &quot;线程停止执行&quot;);
    }
}
</code></pre>
<h2 id="线程插队">线程插队</h2>
<p>  使用join()方法，可实现&quot;插队&quot;效果。当插队的线程运行结束后，其他线程将继续执行。</p>
<pre><code class="language-java">public class Demo4 implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i &lt; 100; i++) {
            System.out.println(&quot;线程VIP来了！&quot; + i);
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        //启动我们的线程
        Demo4 j = new Demo4();
        Thread thread = new Thread(j);
        thread.start();
        //主线程
        for (int i = 0; i &lt; 500; i++) {
            if (i == 200) {
                thread.join();//插队
            }
            System.out.println(&quot;main&quot; + i);
        }
    }
}
</code></pre>
<h2 id="线程优先级">线程优先级</h2>
<p>  可以通过<code>setPriority(优先级)</code>方法设置线程的优先级，优先级从1~10。<br>
  <mark>注意：优先级高的不一定先行执行；</mark></p>
<pre><code class="language-java">//测试线程的优先级
public class Demo5 {
    public static void main(String[] args) {
        System.out.println(Thread.currentThread().getName() + &quot;----&quot; + Thread.currentThread().getPriority());
        Mypriority mypriority = new Mypriority();
        Thread t1 = new Thread(mypriority);
        Thread t2 = new Thread(mypriority);
        Thread t3 = new Thread(mypriority);
        Thread t4 = new Thread(mypriority);
        Thread t5 = new Thread(mypriority);
        Thread t6 = new Thread(mypriority);

        //先设置优先级，再启动
        t1.start();

        t2.setPriority(1);
        t2.start();

        t3.setPriority(4);
        t3.start();

        t4.setPriority(Thread.MAX_PRIORITY);
        t4.start();

        t5.setPriority(3);
        t5.start();

        t6.setPriority(10);
        t6.start();

    }
}

class Mypriority implements Runnable {
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + &quot;----&quot; + Thread.currentThread().getPriority());
    }
}
</code></pre>
<h2 id="守护线程">守护线程</h2>
<p>  守护线程，在没有用户线程可服务时会自动离开。优先级：守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。<br>
  设置：通过setDaemon(true)来设置线程为“守护线程”；将一个用户线程设置为守护线程的方式是在<mark>线程对象创建</mark>之前，用线程对象的setDaemon方法。</p>
<pre><code class="language-java">thread.setDaemon(true);//默认是false，表示保护线程。正常的线程都是用户线程。
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何理解Lambda表达式]]></title>
        <id>https://pizssn.github.io/post/ru-he-li-jie-lambda-biao-da-shi/</id>
        <link href="https://pizssn.github.io/post/ru-he-li-jie-lambda-biao-da-shi/">
        </link>
        <updated>2019-11-18T10:05:58.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>Lambda 表达式（lambda expression）是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象（lambda abstraction），是一个匿名函数，即没有函数名的函数。Lambda表达式可以表示闭包。</p>
</blockquote>
<p>  这里就展示了Lambda是如何从其他表现形式一步步简化成为lambda表达式的，有助于对lambda表达式的理解与使用。</p>
<pre><code class="language-java">//1、先定义一个函数式借接口（就是只有一个抽象类方法）
interface ILike {
    void Lombda();
}

//2、实现类
class Like implements ILike {
    @Override
    public void Lombda() {
        System.out.println(&quot;i like lombda1!&quot;);
    }
}

public class Demo1 {
    //3、静态内部类
    static class Like1 implements ILike {
        @Override
        public void Lombda() {
            System.out.println(&quot;i like lambda2!&quot;);
        }
    }

    public static void main(String[] args) {
        new Like().Lombda();
        new Like1().Lombda();

        //4、局部内部类
        class Like2 implements ILike {
            @Override
            public void Lombda() {
                System.out.println(&quot;i like lambda3!&quot;);
            }
        }
        new Like2().Lombda();

        //5、匿名内部类,没有类的名称，只能靠接口或者父类实现
        ILike i = new ILike() {
            @Override
            public void Lombda() {
                System.out.println(&quot;i liek lambda4!&quot;);
            }
        };
        i.Lombda();

        //6、Lambda
        i = () -&gt; {
            System.out.println(&quot;i like lambda5!&quot;);
        };
        i.Lombda();
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[初识多线程]]></title>
        <id>https://pizssn.github.io/post/duo-xian-cheng/</id>
        <link href="https://pizssn.github.io/post/duo-xian-cheng/">
        </link>
        <updated>2019-11-14T02:02:12.000Z</updated>
        <content type="html"><![CDATA[<p><strong>什么是线程？</strong></p>
<blockquote>
<p>线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p>
</blockquote>
<p><strong>什么是进程？</strong></p>
<blockquote>
<p>进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。</p>
</blockquote>
<p><strong>回到今天的主题，多线程；</strong><br>
 把多个任务分给多个线程,能提高其效率</p>
<ul>
<li>单个线程<br>
<img src="https://pizssn.github.io/post-images/1590546199547.png" alt="" loading="lazy"></li>
<li>多个线程<br>
<img src="https://pizssn.github.io/post-images/1590546245872.png" alt="" loading="lazy"></li>
</ul>
<p><font size=4><strong>实现多线程的三种方式</strong></font></p>
<p><strong>1. 继承Thread类，重写run()方法</strong><br>
<em>Thread本质上也是实现了Runnable接口的一个实例，它代表了一个线程的实例，并且，启动线程的唯一方法就是通过Thread类的start()方法</em></p>
<pre><code class="language-java">//创建线程方式一；继承Thread类，重写run方法，调用start方法开启线程
//线程开启不一定立即执行，而是由CPU调度执行
public class Demo1 extends Thread{
    @Override
    public void run() {
        for (int i=0;i&lt;10;i++)
            System.out.println(&quot;我在练习代码！&quot;+i);
    }
    //main线程，主线程
    public static void main(String[] args) {
        //创建一个线程对象
        Demo1 t = new Demo1();
        //调用start方法开启线程
        t.start();
        for (int i=0;i&lt;2000;i++)
            System.out.println(&quot;我在看视频&quot;+i);
    }
}
</code></pre>
<p><br></br><br>
<strong>2. 实现Runnable接口，并实现run()方法</strong><br>
<em>1）自定义类并实现Runnable接口，实现run()方法。</em><br>
<em>2）创建Thread对象，用实现Runnable接口的对象作为参数实例化该Thread对象</em><br>
<em>3）调用Thread的start()方法</em></p>
<pre><code class="language-java">//创建线程方法二：实现runnable接口，重写run方法，执行线程需要丢入runnable接口实现类，再调用start方法
public class Demo3 implements Runnable {
    public void run() {
        for (int i=0;i&lt;10;i++)
            System.out.println(&quot;我在练习代码！&quot;+i);
    }
    //main线程，主线程
    public static void main(String[] args) {
        //创建一个线程对象
        Demo3 t = new Demo3();
        //Thread thread = new Thread(t);
        //thread.start();
        new Thread(t).start();
        for (int i=0;i&lt;20;i++)
            System.out.println(&quot;我在看视频&quot;+i);
    }
}
</code></pre>
<p><br></br><br>
<strong>3. 实现Callable接口，重写call()方法</strong><br>
<em>1) 实现Callable接口，需要返回值类型</em><br>
<em>2) 重写call方法，需要抛出异常</em><br>
<em>3) 创建目标对象</em><br>
<em>4) 创建执行服务：ExecutorService ser = Executors.newFixedThreadPoll(1);</em><br>
<em>5) 提交执行：Future<Boolean> result = ser.submit(t);</em><br>
<em>6) 获取结果：boolean r = result.get();</em><br>
<em>7) 关闭服务：ser.shutdownNow();</em></p>
<pre><code class="language-java">import java.util.concurrent.*;
//线程创建方式三：实现Callable接口，重写call()方法
public class Demo4 implements Callable {
    @Override
    public Object call() throws Exception {
        for (int i=0;i&lt;10;i++)
            System.out.println(&quot;我在练习代码！&quot;+i);
        return true;
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        Demo4 t = new Demo4();
        //创建执行服务
        ExecutorService ser = Executors.newFixedThreadPool(2);
        //提交执行
        Future&lt;Boolean&gt; r = ser.submit(t);

        for (int i=0;i&lt;2000;i++)
            System.out.println(&quot;我在看视频&quot;+i);
        //获取结果
        boolean rs = r.get();
        //关闭服务
        ser.shutdown();
    }
}
</code></pre>
<p><br></br></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Response重定向]]></title>
        <id>https://pizssn.github.io/post/response-chong-ding-xiang/</id>
        <link href="https://pizssn.github.io/post/response-chong-ding-xiang/">
        </link>
        <updated>2019-10-14T01:07:32.000Z</updated>
        <content type="html"><![CDATA[<p> web资源B在收到客户端A请求后，B会通知A客户端去访问另外一个WEB资源C，这个过程即为重定向<br>
<img src="https://pizssn.github.io/post-images/1590544001570.png" alt="" loading="lazy"></p>
<ul>
<li>语法</li>
</ul>
<pre><code class="language-java">response.sendRedirect(&quot;/r/image&quot;);
</code></pre>
<p><br></br><br>
<strong>请求转发和重定向的区别</strong></p>
<ul>
<li>相同点<br>
页面都会发生跳转</li>
<li>不同点<br>
请求转发的时候，URL不会发生变化，状态码：307<br>
重定向的时候，URL会发生变化，状态码：302</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ServletContext对象]]></title>
        <id>https://pizssn.github.io/post/servletcontext-dui-xiang/</id>
        <link href="https://pizssn.github.io/post/servletcontext-dui-xiang/">
        </link>
        <updated>2019-10-10T06:19:22.000Z</updated>
        <content type="html"><![CDATA[<p>  web容器在启动的时候，它会为每个web程序都创建一个对应的ServletContext对象，他代表了当前的web应用。</p>
<p><strong>共享数据</strong><br>
  在这个servlet中的保存的数据，可以在另外一个servlet中拿到。</p>
<ul>
<li>通过ServletContext保存数据</li>
</ul>
<pre><code class="language-java">package pizssn.servlet;

import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class ContextServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

//        this.getInitParameter()     初始化参数；
//        this.getServletConfig()     servlet参数；
//        this.getServletContext()    servlet上下文；
        ServletContext context = this.getServletContext();
        String username = &quot;pizssn&quot;;     /*数据*/
        context.setAttribute(&quot;username&quot;, username);      /*将一个数据保存在ServletContext中，名字为context*/
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}
</code></pre>
<ul>
<li>从ServletContext获取数据</li>
</ul>
<pre><code class="language-java">package pizssn.servlet;

import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class GetServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        ServletContext context = this.getServletContext();
        String username = (String) context.getAttribute(&quot;username&quot;);
        resp.setContentType(&quot;text/html&quot;);
        resp.setCharacterEncoding(&quot;utf-8&quot;);
        resp.getWriter().print(&quot;名字：&quot; + username);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}
</code></pre>
<p><br></br><br>
<strong>获取初始化参数</strong><br>
  在xml文件配置一些web应用初始化参数</p>
<pre><code class="language-xml">&lt;context-param&gt;
        &lt;param-name&gt;url&lt;/param-name&gt;
        &lt;param-value&gt;jdbc:mysql://localhost:3306/mybaties&lt;/param-value&gt;
&lt;/context-param&gt;
</code></pre>
<p><br></br><br>
<strong>请求转发</strong><br>
  A想拿到的资源只能从C拿到，但是A只能接触到B，B就去C找相应资源，再转给A<br>
<img src="https://pizssn.github.io/post-images/1590495909565.png" alt="" loading="lazy"></p>
<ul>
<li>语法</li>
</ul>
<pre><code class="language-java">        ServletContext context = this.getServletContext();
//        RequestDispatcher requestDispatcher = context.getRequestDispatcher(&quot;/SD1&quot;);
//        requestDispatcher.forward(req,resp);
        context.getRequestDispatcher(&quot;/SD1&quot;).forward(req,resp);
</code></pre>
<p><br></br><br>
<strong>读取资源文件</strong><br>
  Properties(需要一个文件流)</p>
<ul>
<li>在java目录下新建Properties</li>
<li>在resources目录下新建Properties<br>
两者都会被打包到同一个路径下：class（classpath）</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Servlet原理]]></title>
        <id>https://pizssn.github.io/post/servlet-yuan-li/</id>
        <link href="https://pizssn.github.io/post/servlet-yuan-li/">
        </link>
        <updated>2019-10-05T10:51:58.000Z</updated>
        <content type="html"><![CDATA[<p>servlet是由服务器调用，web服务器在收到浏览器请求后一系列流程如下图所示<br>
<img src="https://pizssn.github.io/post-images/1590491693609.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello,Servlet——第一个servlet程序]]></title>
        <id>https://pizssn.github.io/post/helloservlet-di-yi-ge-servlet-cheng-xu/</id>
        <link href="https://pizssn.github.io/post/helloservlet-di-yi-ge-servlet-cheng-xu/">
        </link>
        <updated>2019-10-02T05:57:30.000Z</updated>
        <content type="html"><![CDATA[<p><strong>首先我们要先了解什么是servlet？</strong></p>
<blockquote>
<p>狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。Servlet运行于支持Java的应用服务器中。从原理上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。</p>
</blockquote>
<p>  简单点说就是，servlet是Sun公司开发动态web的一门技术，Sun公司在这些API中提供了一个接口叫做：servlet。</p>
<p><strong>那么，怎么开发一个servlet程序呢？</strong></p>
<p>只需要两个步骤：</p>
<ol>
<li>编写一个类，实现servlet接口。</li>
<li>把开发好的Java类部署到Web服务器中。</li>
</ol>
<p><strong>构建Servlet</strong><br>
servlet接口，Sun公司有两个默认的实现类：HTTPServlet，GenericServlet</p>
<ol>
<li>
<p>构建一个普通的Maven项目</p>
</li>
<li>
<p>Maven环境优化</p>
</li>
</ol>
<ul>
<li>修改web.xml，使其版本为当下最新</li>
</ul>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee
                      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;
         metadata-complete=&quot;true&quot;&gt;
&lt;/web-app&gt;
</code></pre>
<ul>
<li>将maven的结构搭建完整<br>
<img src="https://pizssn.github.io/post-images/1590482629390.png" alt="" loading="lazy"></li>
</ul>
<ol start="3">
<li>编写一个servlet程序</li>
</ol>
<ul>
<li>编写一个普通类</li>
</ul>
<pre><code class="language-java">  public class HelloServlet{

  }
</code></pre>
<ul>
<li>实现servlet接口，这里直接继承HTTPServlet</li>
</ul>
<pre><code class="language-java">import java.io.PrintWriter;

public class HelloServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println(&quot;进入doGet方法！&quot;);
        PrintWriter writer = resp.getWriter();  /*相应流*/
        writer.print(&quot;hello world!&quot;);

    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req, resp);
    }
}
</code></pre>
<ol start="4">
<li>编写servlet的映射，我们写的Java程序，但是要通过浏览器访问，而浏览器需要连接web服务器。所以我们要在web服务器中注册我们的servlet，再为其设置一个浏览器能够访问的路径。</li>
</ol>
<pre><code class="language-xml">    &lt;!--注册servlet--&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
        &lt;servlet-class&gt;pizssn.servlet.HelloServlet&lt;/servlet-class&gt;
    &lt;/servlet&gt;
    &lt;!--servlet的请求路径--&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
</code></pre>
<ol start="5">
<li>配置Tomcat<br>
<img src="https://pizssn.github.io/post-images/1590483470448.png" alt="" loading="lazy"></li>
<li>启动测试<br>
<img src="https://pizssn.github.io/post-images/1590483674409.png" alt="" loading="lazy"></li>
</ol>
]]></content>
    </entry>
</feed>
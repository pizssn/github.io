{"posts":[{"title":"JVM个人小结","content":"什么是JVM？ JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。 引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。 JVM的体系结构： 类加载器（ClassLoader） java提供有3种类加载器 引导（Bootstrap）类加载器、扩展（Extension）类加载器、系统（System）类加载器 类加载器 它用来加载 Java 的核心类，是用原生代码来实现的，负责加载系统类。$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。 Extension类加载器 Extension类加载器是由ExtClassLoader实现的，负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类，由Java语言实现。 System类加载器 系统类加载器是由 Sun 的 AppClassLoader实现的，AppClassLoader负责加载应用类的。它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。 类加载过程 加载：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，会产生一个类对应Class对象 链接：将java类的二进制代码合并到JVM的运行状态之中的过程 验证：确保加载的类信息符合JVM的规范，无安全问题 准备：正式为类变量（static）分配内存并 设置类变量默认初始值 的阶段，这些内存都将在方法区中进行分配。 解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程 初始化： 执行类构造器()方法的过程。类构造器是由编译期自动收集类中的 所有类变量 的赋值动作和静态代码块中的语句合并产生的 当初始化一个类的时候，如果法相其父类还没有进行初始化，则需要先触发其父类的初始化 虚拟机会保证一个类的()方法在对线程环境中被正确加锁和同步 双亲委派机制（确保类的安全性） 某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。这就是加载器的双亲委派机制。 对于任意一个类，都需要由加载它的类加载器和这个类本身来一同确立其在Java虚拟机中的唯一性 为了系统类的安全，类似“ java.lang.Object”这种核心类，jvm需要保证他们生成的对象都会被认定为同一种类型。即通过代理模式，对于 Java 核心库的类的加载工作由引导类加载器来统一完成，保证了 Java 应用所使用的都是同一个版本的 Java 核心库的类，是互相兼容的。为了避免用户自己创建java.lang.Object等系统类，类加载采用委托机制，这样可以保证父类加载器优先，父类加载器能找到的类，子加载器就没有机会加载。例如我们自己写一个System类，会发现根本没有机会得到加载。就是因为System类是Bootstrap加载器加载的，就算自己重写，也总是使用Java系统提供的System。 类加载器间的联系 注意： 虽然上面一直说的是父类加载器，子类加载器，但其实这只是说明一下加载器之间上下层级的关系，而他们本身并不是继承关系，而是组合关系。 组合也是实现类的复用的一种方式。组合是把旧类对象作为新类的成员变量组合起来，用以实现新类的功能，用户看到的是新类的方法，而不能看到被组合对象的方法。因此，通常要在新类里使用private修饰被组合的旧类对象。 那为什么类加载器用的是组合关系而不是继承关系呢？ 因为首先继承在编译时刻就已经定义了，因此无法在运行时刻改变从父类继承的实现。父类通常至少定义了部分子类的具体表示。因为继承对子类揭示了其父类的实现细节，所以继承常被认为“破坏了封装性” 。子类中的实现与它的父类有紧密的依赖关系，以至于父类实现中的任何变化必然会导致子类发生变化。当你需要复用子类时，实现上的依赖性就会产生一些问题 而对象组合是通过获得对其他对象的引用而在运行时刻动态定义的。组合要求对象遵守彼此的接口约定，进而要求更仔细地定义接口，而这些接口并不妨碍你将一个对象和其他对象一起使用。因为对象只能通过接口访问，所以我们并不破坏封装性；只要类型一致，运行时刻还可以用一个对象来替代另一个对象；更进一步，因为对象的实现是基于接口写的，所以实现上存在较少的依赖关系。 对象组合对系统设计还有另一个作用，即优先使用对象组合有助于你保持每个类被封装，并被集中在单个任务上。 本地方法栈 在java程序中，凡是带了native关键字的，说明java的作用范围达不到了，回去调用底层c语言的库，会进入本地方法栈，调用本地方法接口（JNI）。于是本地方法栈将登记native方法，在最终执行的时候，通过JNI加载本地方法库中的方法。 PC寄存器 每个线程都有一个程序计数器(PC寄存器)，是线程私有的，就是一个指针, 指向方法区中的方法字节码(用来存储指向像一条指令的地址， 也即将要执行的指令代码)，在执行引擎读取下一条指令,是一个非常小的内存空间，几乎可以忽略不计。 方法区 方法区是被所有线程共享，所有字段和方法字节码，以及一些特殊方法，如构造函数，接口代码也在此定义。简单说，所有定义的方法的信息都保存在该区域，此区域属于共享区间。 静态变量、常量、类信息(构造方法、接口定义)、运行时的常量池存在方法区中，但是实例变量存在堆内存中，和方法区无关 java栈 java栈主管程序的运行，它耳钉生命周期和线程同步；主线程结束，栈内存就释放。java栈的内部保存一个个的栈帧(Stack Frame)，对应着一次次的java方法调用。 每个栈帧存储着： 局部变量表（Local Variables） 操作数栈（Operand Stack）（或表达式栈） 动态链接（Dynamic Linking）（或指向运行时常量池的方法引用） 方法返回地址（return Address）（或方法正常退出或者异常退出的定义） 后三者也被称为帧数据区 注意：对于栈来说，不存在垃圾回收问题，一旦线程结束，栈就被回收。 堆 堆是java虚拟机所管理的内存中最大的一块。java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。所有的对象实例和数组都要在堆上分配。java堆是垃圾收集器管理的主要区域，因此很多时候也被称作GC堆。 到这里，我们的JVM内部结构就介绍完了，那么一个完整的jvm运行过程是怎样的呢？ Java虚拟机运行过程 一个类文件首先加载到方法区，一些符号引用被解析（静态解析）为直接引用或者等到运行时分派（动态绑定），经过一系列的加载过程（class文件的常量池被加载到方法区的运行时常量池，各种其它的静态存储结构被加载为方法区运行时数据解构等等） 然后程序通过Class对象来访问方法区里的各种类型数据，当加载完之后，程序发现了main方法，也就是程序入口，那么程序就在栈里创建了一个栈帧，逐行读取方法里的代码所转换为的指令，而这些指令大多已经被解析为直接引用了，那么程序通过持有这些直接引用使用指令去方法区中寻找变量对应的字面量来进行方法操作。 操作完成后方法返回给调用方，该栈帧出栈。内存空间被GC回收，堆里被new的那些也就被垃圾回收机制GC了。 全流程包括以下几步：源码编写→编译（javac编译）→类文件被加载到虚拟机（类Class文件结构，虚拟机运行时内存分析，类加载机制）→虚拟机执行二进制字节码（虚拟机字节码执行系统）→垃圾回收（JVM垃圾回收机制） ","link":"https://pizssn.github.io/post/jvm-ge-ren-xiao-jie/"},{"title":"注解与反射小结","content":"注解 Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。Java 语言中的类、方法、变量、参数和包等都可以被标注。和 Javadoc 不同，Java标注可以通过反射获取标注内容。在编译器生成类文件时，标注可以被嵌入到字节码中。Java 虚拟机可以保留标注内容，在运行时可以获取到标注内容， 当然它也支持自定义 Java 标注。 反射 JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；通过获得Class对形成的对象去调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。 java提供了7个注解，分为内置注解与元注解 内置注解 内置注解： Override---重写的注解 Deprecated---不推荐程序员使用，但是可用，或者存在更合适的方式 SuppressWarnings(String[] value)---镇压警告 实例 @Override public String toString() { return super.toString(); } @Deprecated public static void test(){ System.out.println(&quot;Deprecated&quot;); } @SuppressWarnings(&quot;all&quot;) public static void demo(){ ArrayList array = new ArrayList(); } 元注解 负责注解其他注解，可以让你自定义注解 @Targe：用于描述注解的使用范围（即被描述的注解可以用在什么地方） @Retention：表示需要在什么级别保存该注释信息，用于描述注解的生命周期(SOURCE&lt;CLASS&lt;RUNTIME) @Document：说明该注解将被包含在javadoc中 @Inherited：说明子类可以继承父类中的该注解 实例 @MyAnnotation public class MetaAnnotationDemo { @MyAnnotation public void test(){ } } @Inherited @Documented @Retention(RetentionPolicy.RUNTIME) @Target({ElementType.METHOD,ElementType.TYPE}) @interface MyAnnotation{ } 反射：为java提供了动态性，通过获得Class对形成的对象及其进行操作。 反射的核心就是获取Class方法。因此我们先了解一下什么是类加载。 加载：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，会产生一个类对应Class对象 链接：将java类的二进制代码合并到JVM的运行状态之中的过程 验证：确保加载的类信息符合JVM的规范，无安全问题 准备：正式为类变量（static）分配内存并 设置类变量默认初始值 的阶段，这些内存都将在方法区中进行分配。 解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程 初始化： 执行类构造器()方法的过程。类构造器是由编译期自动收集类中的 所有类变量 的赋值动作和静态代码块中的语句合并产生的 当初始化一个类的时候，如果法相其父类还没有进行初始化，则需要先触发其父类的初始化 虚拟机会保证一个类的()方法在对线程环境中被正确加锁和同步 类的主动引用（一定是类的初始化） 当虚拟机启动，先初始化main所在的类 new一个类的对象 调用类的静态成员（除了final常量）和静态方法 使用java.lang.reflect包的方法对其类进行反射调用 当初始化一个类，如果其父类没有被初始化，则会初始化它的父类 类的被动引用（不会发生类的初始化） 当访问一个静态域时，只有真声明这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类初始化 通过数组定义类引用，不会触发此类的初始化 引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了） 反射有三种获取方式，还有一种是获取基本内置类型包装类的Class： //获得Class的方式一：通过对象获得 Person person = new Student(); Class&lt;? extends Person&gt; aClass1 = person.getClass(); //获得Class的方式二：通过forName获得 Class&lt;?&gt; aClass2 = Class.forName(&quot;pizssn.Reflection.Student&quot;); //获得Class的方式三：通过类名.Class获得 Class&lt;Student&gt; aClass3 = Student.class; //获得Class的方式四：基本内置类型的包装类都有一个Type属性 Class&lt;Integer&gt; aClass4 = Integer.TYPE; 在获取到Class对象之后，我们就可以通过反射的一些方法获取到类的一些信息。 获取类的名字： public String getName()：返回由类对象表示的实体的名称（类，接口，数组类，原始类型或void），作为String。 public String getSimpleName()：返回源代码中给出的基础类的简单名称。如果基础类是匿名的，则返回一个空字符串。 获取类的属性： public Field getField(String name)：返回一个Field对象，它反映此表示的类或接口的指定公共成员字段类对象。 public Field[] getFields()：返回包含一个数组Field对象反射由此表示的类或接口的所有可访问的公共字段类对象。 public Field getDeclaredField(String name)：返回一个Field对象，它反映此表示的类或接口的指定已声明字段类对象。 获取类的方法： public Method getMethod(String name,Method&lt;?&gt;... parameterTypes)：返回一个方法对象，它反映此表示的类或接口的指定公共成员方法类对象。 public Method[] getMethods()：返回包含一个数组方法对象反射由此表示的类或接口的所有公共方法类对象，包括那些由类或接口和那些从超类和超接口继承的声明。 public Method[] getDeclaredMethods()：返回包含一个数组方法对象反射的类或接口的所有声明的方法，通过此表示类对象，包括公共，保护，默认（包）访问和私有方法，但不包括继承的方法。 获取类的构造器： public Constructor&lt;T&gt; getConstructor(Method&lt;?&gt;... parameterTypes)：返回一个Constructor对象，该对象反映Constructor对象表示的类的指定的公共类函数。 public Constructor&lt;?&gt;[] getConstructors()：返回一个包含Constructor对象的数组，反映由此Constructor对象表示的类的所有公共类函数。 public Constructor&lt;?&gt;[] getDeclaredConstructors()：返回反映Constructor对象表示的类声明的所有Constructor对象的数组类。 通过反射动态创建对象与方法 public T newInstance()：创建由此类对象表示的类的新实例。该类被实例化为一个具有空参数列表的new表达式。 如果类尚未初始化，则初始化该类。 public Object invoke(Object obj,Object... args)：在具有指定参数的方法对象上调用此方法对象表示的基础方法。 public void setAccessible(boolean flag)：将此对象的accessible标志设置为指示的布尔值。 true的值表示反射对象应该在使用时抑制Java语言访问检查。 false的值表示反映的对象应该强制执行Java语言访问检查。 之所以将注解和反射一起放在这总结，是因为我们可以通过反射获取注解信息。 //通过反射获得注解 Annotation[] annotations = aClass.getAnnotations(); //获得注解的value值 tablePizssn annotation = (tablePizssn) aClass.getAnnotation(tablePizssn.class); 当然，反射也是动态代理的一种实现方式。 这种实现方式需要使用到一个类Proxy和一个接口InvocationHandler。Proxy是所有动态类的父类，它提供一个静态方法来创建动态代理的class对象和实例，这个方法就是newProxyInstance()。 反射实现动态代理的逻辑：代理类调用接口方法→调用invocationHandler.invoke方法→反射调用指定被代理类方法→Proxy.newProxyInstance 生成代理类 ","link":"https://pizssn.github.io/post/zhu-jie-yu-fan-she-xiao-jie/"},{"title":"HashMap你必须知道的那些知识点","content":"HashMap是如何实现的？ HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度依然为O(1)，因为最新的Entry会插入链表头部，只需要简单改变引用链即可，而对于查找操作来讲，在定位到数组相应的结点之后，还需要遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。 HashMap是线程安全的吗？ HashMap是线程不安全的。 在多线程环境下，使用HashMap进行put操作会导致HashMap的Entry链表形成环形数据结构，一旦形成环形数据结构，Entry的next节点永远不为空，就会产生死循环，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap。 那有什么线程安全的结构呢？ HashTable HashTable是使用synchronized来保证线程的安全。当一个线程访问HashTable的同步方法，其他方法访问HashTable的同步方法时，会进入阻塞或者轮询状态。如果线程A使用put进行元素添加，线程B不但不能用put方法添加于元素同是也无法用get方法来获取元素，所以竞争越激烈效率越低，因此它被淘汰了。 ConcurrentHashMap HashTable容器在竞争激烈的并发环境效率低下的原因是所有访问HashTable的线程都必须竞争同一把锁。那假如容器有多把锁，每一把锁用于锁住容器中一部分数据，那么多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效提高并发访问率，这就是ConcurrentHashMap的锁分段技术。将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一段数据的时候，其他段的数据也能被其他线程访问。 ConcurrentHashMap插入、查询逻辑 put： 1.定位segment并确保定位的Segment已初始化 2.调用Segment的put方法。 Get： 先定位Segment，再定位HashEntry ","link":"https://pizssn.github.io/post/hashmap-ni-bi-xu-zhi-dao-de-na-xie-zhi-shi-dian/"},{"title":"java集合笔记","content":" 在了解集合最初，我们必须要了解它的含义。 集合类是Java数据结构的实现。Java的集合类是java.util包中的重要内容，它允许以各种方式将元素分组，并定义了各种使这些元素更容易操作的方法。Java集合类是Java将一些基本的和使用频率极高的基础类进行封装和增强后再以一个类的形式提供。集合类是可以往里面保存多个对象的类，存放的是对象，不同的集合类有不同的功能和特点，适合不同的场合，用以解决一些实际问题。 首先，在最前面来个图，这个图十分经典（偶然间看到的），实线边框的是实现类，折线边框的是抽象类，而点线边框的是接口。带有空心箭头的点线表示一个特定的类实现了一个接口，实心箭头表示某个类可以生成箭头所指向类的对象 这个就是java集合的一个初步的关系，其中Iterator是迭代器，是java为各种容器提供的公共的操作接口。这样使得对容器的遍历操作与其具体的底层实现相隔离，达到解耦的效果。接下来我们将逐一认识他们。 首先，java集合分两大类，一类为实现Collection接口，另一类为实现Map接口。这就衍生出两类集合派别。 Collection 它是一个线性，存放的是value Map 它是一组键值对的对象，存放的是key：value Iterator 前面提到了Iterator是java为各种容器提供的公共的操作接口，俗称迭代器，是集合的专用遍历方式。构造方法：Iterator&lt;E&gt; iterator() 返回此集合中元素的迭代器 迭代器是通过集合的iterator()方法得到的，所以我们说它是依赖于集合而存在的 迭代器中的常用方法 E next()：返回迭代中的下一个元素 boolean hasNext()，如果迭代具有更多元素，则返回true void remove():从迭代器中指向的集合中移除迭代器返回的最后一个元素（可选操作） Collection接口是单例集合的顶层接口，JDK不提供此类的任何直接实现。它下面还有三个子接口，一个为可重复的List接口，另一个为不可重复的Set接口，还有一个为Queue。 List接口 有序：存储和取出的元素顺序一致 可重复：存储的元素可以重复 List接口有两个实现类，一个为ArrayList类，另一个为LinkedList类 ArratList底层用的数据结构是数组，查询快，增删慢 ArrayList构造方法： public ArrayList()：创建一个空的集合对象 ArrayList添加方法： public boolean add(E e)：将指定的元素追加到此集合的末尾 public void add(int index,E element)：在此集合中的指定位置插入指定的元素 ArrayList常用方法： public boolean remove(Object o)：删除指定的元素，返回删除是否成功 public E remove(int index)：删除指定索引处的元素，返回被删除的元素 public E set(int index,E element)：修改指定索引处的元素，返回被修改的元素 public E get(int index)：返回指定索引处的元素 public int size()：返回集合中的元素的个数 LinkedList底层用的数据结构是链表，增删快，查询慢 LinkedList集合的特有功能： public void addFirst(E e)：在该列表开头插入指定的元素 public void addLast(E e)：将指定的元素追加到此列表的末尾 public E getFirst()：返回此列表中的第一个元素 public E getLast()：返回此列表中的最后一个元素 public E removeFirst()：从此列表中删除并返回第一个元素 public E removeLast()：从此列表中删除并返回最后一个元素 List还有一个特有的列表迭代器——ListIterator 通过List集合的ListIterator()方法得到，所以说它是List集合特有的迭代器。用于允许程序员沿任一方向遍历列表的列表迭代器，在迭代期间修改列表，并获取列表中迭代器的当前位置。 ListIterator()中的常用方法： E next()：返回迭代中的下一个元素 boolean hasNext()：如果迭代具有更多元素，则返回true E previous()：返回列表中的上一个元素 boolean hasPrevious()：如果此列表迭代器在相反方向遍历列表时具有更多元素，则返回true void add(E e)：将指定的元素插入列表 实例： List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;hello&quot;); list.add(&quot;world&quot;); list.add(&quot;java&quot;); //列表迭代器搭建一次就行了 ListIterator&lt;String&gt; lit = list.listIterator(); while(lit.hasNext()){ String s = lit.next(); System.out.println(s); } while(lit.hasPrevious()){ String s1 = lit.previous(); } //在这里并不会出现并发异常，因为在ListIterator接口下的实现类有个方法是把实际修改集合次数赋值给预期修改次数 //如果这里是Iterator，则会产生并发异常，因为Iterator下的next方法会把实际修改次数与预期修改次数对比，不相等则抛出一个异常 ListIterator&lt;String&gt; lits = list.listIterator(); while (lits.hasNext()){ String s = lits.next(); if (s.equals(&quot;world&quot;)){ lits.add((&quot;Javaee&quot;)); } } Set接口 不包含重复元素的集合 没有带索引的方法，所以不能使用普通for循环遍历，因为不能用set.get()获取元素。 Set接口有两个实现类，一个为HashSet类，另一个为TreeSet类 HashSet 底层数据结构是哈希表 对集合的迭代顺序不做任何保证，也就是说不保证存储和取出的元素顺序一致 没有带索引的方法，因此不能使用普通for循环遍历 由于是Set集合，所以是不包含重复元素的集合 同时，LinkedHashSet继承了HashSet，源码更少、更简单，唯一的区别是内部使用的是LinkedHashMap。 哈希表和链表实现的Set接口，具有可预测的迭代顺序 由链表保证元素有序，也就是说元素的存储和取出顺序是一致的 有哈希表保证元素唯一，也就是说没有重复的元素 这里解释一下Set集合保证元素唯一性的方法 ①你存入一个元素，会根据元素的哈希值计算对象的存储位置，如果该位置没有对象，则存入元素 ②如果该位置有元素，则遍历该位置的所有元素，将存入的元素会和以前的元素比较哈希值 如果哈希值不同，会继续往下执行，把元素添加到集合 ③如果哈希值相同，会调用对象的equals()方法比较 如果返回false，会继续向下执行，把元素添加到集合 如果返回true，说明元素重复，不存储 TreeSet 元素有序，这里的顺序不是指存储和取出的顺序，而是按照一定的规则进行排序，具体排序方式取决于构造方法 TreeSet()：根据其元素的自然排序进行排序 TreeSet(Comparator comparator)：根据指定的比较器进行排序 没有带索引的方法，所以不能使用普通的for循环遍历 由于是set集合，所以不包括重复元素的集合 Queue Queue也是Collection的子接口。不过通常情况下，LinkedList可以被用作Queue的一种实现，因为它实现了Queue的接口。不过还有一个类，叫PriorityQueue，它是一个比较标准的队列实现类，但不是绝对标准。因为PriorityQueue保存队列元素的顺序并不是按加入队列的顺序，而是按队列元素的大小进行重新排序。因此当调用peek()、pull()方法来取出队列中的元素时，并不是取出最先进入队列的元素，而是取出队列中最小的元素。这其实违背了先进先出(FIFO)规则。 Map接口是键值对集合的顶层接口，JDK也不提供此类的任何直接实现。 它的结构为Interface Map&lt;K,V&gt; K：键的类型 V：值的类型。Map集合将键映射到值的对象,同时不能包含重复的键，每个键可以映射到最多一个值。它下面还有两个子接口，一个为AbstractMap接口，另一个为SortedMap接口。其中他们的实现类中比较常用的就是HashMap，TreeMap了。 HashMap HashMap是我们使用最多的一个Map具体类。它是根据键的HashCode值来存储数据，根据键可以直接获取它的值，访问速度极快，但数据的存储是无序的。并且HashMap允许key和value都为null。 HashMap基本方法： V put(K key,V value)：添加元素 V remove(Object key)：根据键删除键值对元素，返回键所对应的值 void clear()：移除所有的键值对元素 boolean containsKey(Object value)：判断集合是否包含指定的键 boolean containsValue(Object value)：判断集合是否包含指定的值 boolean isEmpty()：判断集合是否为空 int size()：集合的长度，也就是集合中键值对的个数 V get(Object key)：根据键获取值 Set&lt;K&gt; keySet()：获取所有键的集合 Collection&lt;V&gt; values()：获取所有值的集合 Map集合遍历有两种方式， 方式一： 1、获取所有键的集合，用keyset()实现； 2、遍历键的集合，获取到每一个键 3、根据键去找值，用get(Object key方法实现) 方式二： 1、获取所有键值对对象的集合 Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()：获取所有键值对对象的集合 2、遍历键值对对象的集合，得到每一个键值对对象 3、根据键值对对象获取键和值。用getKey()得到键，用getValue()得到值 实例 Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put(&quot;a0001&quot;, &quot;pizssn&quot;); map.put(&quot;a0002&quot;, &quot;yettaa&quot;); map.put(&quot;a0003&quot;, &quot;piyiyi&quot;); map.put(&quot;a0004&quot;, &quot;johnnn&quot;); //第一种方式 Set&lt;String&gt; set = map.keySet(); for (String s : set) { System.out.println(s + &quot;---&quot; + map.get(s)); } //第二种方式 Set&lt;Map.Entry&lt;String, String&gt;&gt; sm = map.entrySet(); for (Map.Entry&lt;String, String&gt; m : sm) { System.out.println(m.getKey() + &quot;---&quot; + m.getValue()); } 当然HashMap知识点远不止这些，没讲的会放在另外一个博客去扩展。 LinkedHashMap继承自HashMap，它相较于HashMap，最大的优点就是可以实现迭代有序，这个有序可以是插入顺序或者访问顺序。作为牺牲，它增加了时间和空间上的开销。因为它是通过维护一个运行于所有条目的双向链表，来实现元素迭代有序。Key和Value也都允许为null。 TreeMap TreeMap实现了SortMap接口，因此TreeMap是Key有序的。它默认的排序规则是升序排序，当然开发者也可以指定排序比较器，修改排序规则。TreeMap是基于红黑树实现的，其默认的节点颜色是黑色。当然要注意的一点是插入的键值不能为null。 Collections类 很多人都会把Collection和Collections弄混，Collection是单例集合的顶层接口，而Collections是针对集合操作的工具类。 Collections类的常用方法： public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list)：将指定的列表 public static void reverse(List&lt;?&gt; list)：反转指定元素的顺序 public static void shuffle(List&lt;?&gt; list)：使用默认源随机排列指定的列表 ","link":"https://pizssn.github.io/post/java-ji-he-bi-ji/"},{"title":"Date类以及Calendar类","content":"Date类和Calendar类均是对时间进行的一些表示。 首先来看一下Date类的构造方法： Date()：根据当前的默认毫秒值创建日期对象 Date(long date)：根据给定的毫秒值创建日期对象 System.out.println(new Date());//结果：Fri Jun 05 15:09:27 CST 2020 System.out.println(new Date(1000*60*60));//结果：Thu Jan 01 09:00:00 CST 1970 //从1970年凌晨的时间算起，之所以是Thu Jan 01 09:00:00 CST 1970，是因为我们是东八区 当然表示日期我们最常用的就是SimpleDateFormat类了，SimpleDateFormat是DateFormat的具体子类，而DateFormat是可以进行日期和字符串的格式化解析的一个抽象类。 SimpleDateFormat的构造方法： SimpleDateFormat()：默认模式 SimpleDateFormat(String pattern)：给定的模式 年 y 月 M 日 d 时 H 分 m 秒 s 当然在你得到当前日期信息之后，你还需要进行格式化，将其转化为我们能看的懂得信息。 Date → String(格式化) public final String format(Date date) String → Date(解析) public Date parse(String source) 举个栗子,获取现在的年月日以及时间 String s = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;).format(d); 注意：时分秒要用:号隔开。 还有一个表示时间的类为Calendar类 Calender为特定瞬间与一组诸如YEAR、MONTH、DAY_OF_MONTH、HOUR等日历字段之间的转换提供了一些方法，并为操作日历字段（如获得下星期的日期）提供了一些方法 public int get(int field)：返回给定日历字段的值，日历类中的每个日历字段都是静态的成员变量，并且是int类型 public abstract void add(int field,int amount)：根据给定的日历字段和对应的时间，来对当前的日历进行操作 public final void set(int year,int month,int date)：设置当前日期的年月日 获取当前日期 Calendar rightNow = Calendar.getInstance();//因为Calendar是抽象类，不能实例化对象，所以这里返回的是子类的对象 int year = rightNow.get(Calendar.YEAR); int month = rightNow.get(Calendar.MONTH)+1;//之所以加1，是因为MONTH是从零开始的 int date = rightNow.get(Calendar.DATE); System.out.println(year+&quot;年&quot;+month+&quot;月&quot;+date+&quot;日&quot;); ","link":"https://pizssn.github.io/post/date-lei-yi-ji-calendar-lei/"},{"title":"BigDecimal——解决float与double的精度问题","content":"首先在最开始之前，让我们来看一段代码。 System.out.println(0.09+0.01); System.out.println(1.0-0.32); System.out.println(1.015*100); System.out.println(1.301/100); 你觉得答案是什么呢？0.10 , 0.68 , 101.5 ， 0.01301吗？ 不是的 答案是： 0.09999999999999999 0.6799999999999999 101.49999999999999 0.013009999999999999 对于这个结果你会不会很惊讶？ 其实是因为浮点数是由符号位、指数、尾数组合而成，而其中指数是由移码表示，尾数是由补码表示。尾数是有长度限制的，而有些小数换算成二进制时，超过了这个长度，因此只能通过四舍五入得到一个近似值。 所以浮点运算很少是精确的，只要是超过精度能表示的范围就会产生误差。往往产生误差不是因为数的大小，而是因为数的精度。因此，产生的结果接近但不等于你所想要的结果。 因此我们利用BigDecimal来解决这个问题 BigDecimal方达如下： public BigDecimal add(BigDecimal augend)：加 public BigDecimal subtract(BigDecimal subtrahend)：减 public BigDecimal multiply(BigDecimal multiplicand)：乘 public BigDecimal divide(BigDecimal divisor)：除 public BigDecimal divide(BigDecimal divisor,int scale,int roundingMode)：商，几位小数。如何舍取 采用BigDecimal进行上面的运算 System.out.println(new BigDecimal(&quot;0.09&quot;).add(new BigDecimal(&quot;0.01&quot;)));//这里一定要是字符串才算是调用BigDemical构造方法 System.out.println(new BigDecimal(&quot;1.0&quot;).subtract(new BigDecimal(&quot;0.32&quot;)));//如果是float与double类型，得到的依旧是不精确的数值 System.out.println(new BigDecimal(&quot;1.015&quot;).multiply(new BigDecimal(&quot;100&quot;))); System.out.println(new BigDecimal(&quot;1.301&quot;).divide(new BigDecimal(&quot;100&quot;))); System.out.println(new BigDecimal(&quot;1.301&quot;).divide(new BigDecimal(&quot;100&quot;),3,BigDecimal.ROUND_HALF_UP));//ROUND_HALF_UP是四舍五入 发现结果正常 0.10 0.68 101.500 0.01301 0.013 ","link":"https://pizssn.github.io/post/bigdecimal-jie-jue-float-yu-double-de-jing-du-wen-ti/"},{"title":"String类的一些需要注意的问题","content":"一、String s = new String[&quot;hello&quot;]与String s = &quot;hello&quot;有什么区别？ 相信很多人都面对过这个问题，其实也不难理解。 String s = new String[&quot;hello&quot;]会先检查常量池当中是否有hello对象，有则返回对象，没有就创建对应的实例对象。然后在堆中 new String (&quot;hello&quot;)，然后将对象地址赋值给s。 String s = &quot;hello&quot;会先到常量池中查找是否存在hello这个字符串，如果有，那么返回已经存在字符串的引用，如果不存在,那么就创建字符串对象，并且返回引用。 他们的区别就是： 前者会在堆中开辟一个空间，会创建两个对象（如果方法区的常量池中无你所需要的变量） 后者只会创建一个对象（在方法区的常量池中寻找需要的变量） String s1 = new String(&quot;hello!&quot;); String s2 = &quot;hello!&quot;; System.out.println(s1 == s2);//比较的地址值，此地址值new出来的是指向的是堆里面的地址，然后再指向方法区的某个地址。直接创建的直接指向方法区的某个地址。 System.out.println(s1.equals(s2));//比较的内容（重写之后的） 结果 二、String s = &quot;&quot;与String s = NULL意义相同吗？ 不相同 前者表示字符串为空 后者表示字符串对象为空 三、字符串的转换功能 byte[] getBytes()：把字符串转换为字节数组 char[] toCharArray()：把字符串转换为字符数组 Static String valueOf(char[] chs)：把字符数组转化为字符串 Static String valueOf(int i)：把int类型的数据转换为字符串 ······ 注意：String类的valueOf方法可以把任意类型的数据转成字符串 四、字符串的传参 String作为参数传递，效果和基本类型作为参数传递是一样的，形式参数的改变不影响实际参数。而StringBuffer就是引用类型，形式参数的改变直接影响实际参数。 public class StringBufferDemo { public static void main(String[] args) { String s1 = &quot;hello&quot;; String s2 = &quot;world&quot;; System.out.println(s1 + s2); change(s1, s2);//String在这里是作为形参传递，不改变实际上的值 System.out.println(s1 + s2); StringBuffer sb1 = new StringBuffer(&quot;hello&quot;); StringBuffer sb2 = new StringBuffer(&quot;world&quot;); System.out.println(sb1 + &quot;&quot; + sb2); change(sb1, sb2); System.out.println(sb1 + &quot;&quot; + sb2); } public static void change(String str1, String str2) { str1 = str2; str2 = str1 + str2; } public static void change(StringBuffer str1, StringBuffer str2) { str1 = str2; str2.append(str1); } 五、String,StringBuffer,StringBuilder的区别 String是内容不可变的，而StringBuffer，StringBuilder都是内容可变的 在多线程下而言，StringBuffer是同步的，数据安全，但是效率低；而StringBuilder是不同步的，数据不安全，效率高。 六、StringBuffer和数组的区别 相同点：二者都可以看做是一个容器，装其他的数据。 不同点：StringBuffer的数据最终是一个字符串数据；而数组可以放置多种数据，但必须是同一种数据类型。 ","link":"https://pizssn.github.io/post/string-lei-de-yi-xie-xu-yao-zhu-yi-de-wen-ti/"},{"title":"线程安全及案例","content":"什么是线程安全？ 多个线程同一时刻对同一个全局变量(同一份资源)做写操作(读操作不会涉及线程安全)时，如果结果跟我们预期的一样，我们就称之为线程安全，反之，线程不安全。 为了保证线程的安全，最简单的方法就是给相应的方法、对象等加synchronized关键字。 什么是synchronized？ 一般说的synchronized用来做多线程同步功能，其实synchronized只是提供多线程互斥，而对象的wait()和notify()方法才提供线程的同步功能。 synchronized是加锁，或者说是加对象锁，其实对象锁只是synchronized在实现锁机制中的一种锁（重量锁，用这种方式互斥线程开销大所以叫重量锁，或者叫对象monitor），而synchronized的锁机制会根据线程竞争情况在运行会有偏向锁、轻量锁、对象锁，自旋锁（或自适应自旋锁）等，总之，synchronized可以认为是一个几种锁过程的封装。 案例 添加进程进ArrayList,存在线程不安全的隐患 import java.util.ArrayList; public class Demo { public static void main(String[] args) { ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10000; i++) { new Thread(()-&gt;{ list.add(Thread.currentThread().getName()); }).start(); } try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(list.size()); } } 结果：明明向里面添加了10000个进程，最后ArrayList里只有8050个。 改进方案：添加synchronized关键字，给list上锁。 import java.util.ArrayList; public class Demo3Synchronous { public static void main(String[] args) { ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10000; i++) { new Thread(() -&gt; { synchronized (list) { list.add(Thread.currentThread().getName()); } }).start(); } try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(list.size()); } } 结果：ArrayList有10000个进程。 ","link":"https://pizssn.github.io/post/xian-cheng-an-quan-ji-an-li/"},{"title":"线程方法学习","content":" 列举了几个线程常用方法。 线程停止 建议线程正常停止，利用次数，不建议死循环 建议使用标志位，设置一个标志位 不要使用stop或者destroy等过时或JDK不建议使用的法 public class Demo1 implements Runnable { //设置一个标识位 private boolean flag = true; @Override public void run() { int i = 0; while (flag) { System.out.println(&quot;run...Thread&quot; + i++); } } //设置一个公开的方法停止线程，转换标志位 public void stop() { this.flag = false; } public static void main(String[] args) { Demo1 d = new Demo1(); new Thread(d).start(); for (int i = 0; i &lt; 10000; i++) { System.out.println(&quot;main&quot; + i); if (i == 9000) { //调用stop方法切换标志位，让线程停止 d.stop(); System.out.println(&quot;该线程停止&quot;); } } } } 线程休眠 sleep() 的作用是让当前线程休眠，即当前线程会从“运行状态”进入到“休眠(阻塞)状态”。sleep()会指定休眠时间，线程休眠的时间会大于/等于该休眠时间；在线程重新被唤醒时，它会由“阻塞状态”变成“就绪状态”，从而等待cpu的调度执行。 注意：sleep()和wait()是有区别的。wait()的作用是让当前线程由“运行状态”进入“等待(阻塞)状态”的同时，也会释放同步锁。而sleep()的作用是也是让当前线程由“运行状态”进入到“休眠(阻塞)状态”。但是，wait()会释放对象的同步锁，而sleep()则不会释放锁。 import java.text.SimpleDateFormat; import java.util.Date; //sleep的功能 public class Demo2 { public static void main(String[] args) throws InterruptedException { //打印当前系统时间 Date currentTime = new Date();//获取系统当前时间 while (true) { try { Thread.sleep(1000); System.out.println(new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(currentTime)); currentTime = new Date();//刷新系统当前时间 } catch (InterruptedException e) { e.printStackTrace(); } } } public static void TimeDown(int num) throws InterruptedException { //模拟倒计时的功能 while (true) { Thread.sleep(1000); System.out.println(num--); if (num &lt; 0) break; } } } 线程礼让 只是让原来已经执行的线程先退出来重新竞争资源，还是得看CPU分配。 public class Demo3 { public static void main(String[] args) { MyYield m = new MyYield(); new Thread(m, &quot;a&quot;).start(); new Thread(m, &quot;b&quot;).start(); new Thread(m, &quot;c&quot;).start(); } } class MyYield implements Runnable { @Override public void run() { System.out.println(Thread.currentThread().getName() + &quot;线程开始执行&quot;); Thread.yield();//线程礼让 System.out.println(Thread.currentThread().getName() + &quot;线程停止执行&quot;); } } 线程插队 使用join()方法，可实现&quot;插队&quot;效果。当插队的线程运行结束后，其他线程将继续执行。 public class Demo4 implements Runnable { @Override public void run() { for (int i = 0; i &lt; 100; i++) { System.out.println(&quot;线程VIP来了！&quot; + i); } } public static void main(String[] args) throws InterruptedException { //启动我们的线程 Demo4 j = new Demo4(); Thread thread = new Thread(j); thread.start(); //主线程 for (int i = 0; i &lt; 500; i++) { if (i == 200) { thread.join();//插队 } System.out.println(&quot;main&quot; + i); } } } 线程优先级 可以通过setPriority(优先级)方法设置线程的优先级，优先级从1~10。 注意：优先级高的不一定先行执行； //测试线程的优先级 public class Demo5 { public static void main(String[] args) { System.out.println(Thread.currentThread().getName() + &quot;----&quot; + Thread.currentThread().getPriority()); Mypriority mypriority = new Mypriority(); Thread t1 = new Thread(mypriority); Thread t2 = new Thread(mypriority); Thread t3 = new Thread(mypriority); Thread t4 = new Thread(mypriority); Thread t5 = new Thread(mypriority); Thread t6 = new Thread(mypriority); //先设置优先级，再启动 t1.start(); t2.setPriority(1); t2.start(); t3.setPriority(4); t3.start(); t4.setPriority(Thread.MAX_PRIORITY); t4.start(); t5.setPriority(3); t5.start(); t6.setPriority(10); t6.start(); } } class Mypriority implements Runnable { @Override public void run() { System.out.println(Thread.currentThread().getName() + &quot;----&quot; + Thread.currentThread().getPriority()); } } 守护线程 守护线程，在没有用户线程可服务时会自动离开。优先级：守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。 设置：通过setDaemon(true)来设置线程为“守护线程”；将一个用户线程设置为守护线程的方式是在线程对象创建之前，用线程对象的setDaemon方法。 thread.setDaemon(true);//默认是false，表示保护线程。正常的线程都是用户线程。 ","link":"https://pizssn.github.io/post/xian-cheng-fang-fa-xue-xi/"},{"title":"如何理解Lambda表达式","content":" Lambda 表达式（lambda expression）是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象（lambda abstraction），是一个匿名函数，即没有函数名的函数。Lambda表达式可以表示闭包。 这里就展示了Lambda是如何从其他表现形式一步步简化成为lambda表达式的，有助于对lambda表达式的理解与使用。 //1、先定义一个函数式借接口（就是只有一个抽象类方法） interface ILike { void Lombda(); } //2、实现类 class Like implements ILike { @Override public void Lombda() { System.out.println(&quot;i like lombda1!&quot;); } } public class Demo1 { //3、静态内部类 static class Like1 implements ILike { @Override public void Lombda() { System.out.println(&quot;i like lambda2!&quot;); } } public static void main(String[] args) { new Like().Lombda(); new Like1().Lombda(); //4、局部内部类 class Like2 implements ILike { @Override public void Lombda() { System.out.println(&quot;i like lambda3!&quot;); } } new Like2().Lombda(); //5、匿名内部类,没有类的名称，只能靠接口或者父类实现 ILike i = new ILike() { @Override public void Lombda() { System.out.println(&quot;i liek lambda4!&quot;); } }; i.Lombda(); //6、Lambda i = () -&gt; { System.out.println(&quot;i like lambda5!&quot;); }; i.Lombda(); } } ","link":"https://pizssn.github.io/post/ru-he-li-jie-lambda-biao-da-shi/"},{"title":"初识多线程","content":"什么是线程？ 线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。 什么是进程？ 进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。 回到今天的主题，多线程； 把多个任务分给多个线程,能提高其效率 单个线程 多个线程 实现多线程的三种方式 1. 继承Thread类，重写run()方法 Thread本质上也是实现了Runnable接口的一个实例，它代表了一个线程的实例，并且，启动线程的唯一方法就是通过Thread类的start()方法 //创建线程方式一；继承Thread类，重写run方法，调用start方法开启线程 //线程开启不一定立即执行，而是由CPU调度执行 public class Demo1 extends Thread{ @Override public void run() { for (int i=0;i&lt;10;i++) System.out.println(&quot;我在练习代码！&quot;+i); } //main线程，主线程 public static void main(String[] args) { //创建一个线程对象 Demo1 t = new Demo1(); //调用start方法开启线程 t.start(); for (int i=0;i&lt;2000;i++) System.out.println(&quot;我在看视频&quot;+i); } } 2. 实现Runnable接口，并实现run()方法 1）自定义类并实现Runnable接口，实现run()方法。 2）创建Thread对象，用实现Runnable接口的对象作为参数实例化该Thread对象 3）调用Thread的start()方法 //创建线程方法二：实现runnable接口，重写run方法，执行线程需要丢入runnable接口实现类，再调用start方法 public class Demo3 implements Runnable { public void run() { for (int i=0;i&lt;10;i++) System.out.println(&quot;我在练习代码！&quot;+i); } //main线程，主线程 public static void main(String[] args) { //创建一个线程对象 Demo3 t = new Demo3(); //Thread thread = new Thread(t); //thread.start(); new Thread(t).start(); for (int i=0;i&lt;20;i++) System.out.println(&quot;我在看视频&quot;+i); } } 3. 实现Callable接口，重写call()方法 1) 实现Callable接口，需要返回值类型 2) 重写call方法，需要抛出异常 3) 创建目标对象 4) 创建执行服务：ExecutorService ser = Executors.newFixedThreadPoll(1); 5) 提交执行：Future result = ser.submit(t); 6) 获取结果：boolean r = result.get(); 7) 关闭服务：ser.shutdownNow(); import java.util.concurrent.*; //线程创建方式三：实现Callable接口，重写call()方法 public class Demo4 implements Callable { @Override public Object call() throws Exception { for (int i=0;i&lt;10;i++) System.out.println(&quot;我在练习代码！&quot;+i); return true; } public static void main(String[] args) throws ExecutionException, InterruptedException { Demo4 t = new Demo4(); //创建执行服务 ExecutorService ser = Executors.newFixedThreadPool(2); //提交执行 Future&lt;Boolean&gt; r = ser.submit(t); for (int i=0;i&lt;2000;i++) System.out.println(&quot;我在看视频&quot;+i); //获取结果 boolean rs = r.get(); //关闭服务 ser.shutdown(); } } ","link":"https://pizssn.github.io/post/duo-xian-cheng/"},{"title":"Response重定向","content":" web资源B在收到客户端A请求后，B会通知A客户端去访问另外一个WEB资源C，这个过程即为重定向 语法 response.sendRedirect(&quot;/r/image&quot;); 请求转发和重定向的区别 相同点 页面都会发生跳转 不同点 请求转发的时候，URL不会发生变化，状态码：307 重定向的时候，URL会发生变化，状态码：302 ","link":"https://pizssn.github.io/post/response-chong-ding-xiang/"},{"title":"ServletContext对象","content":" web容器在启动的时候，它会为每个web程序都创建一个对应的ServletContext对象，他代表了当前的web应用。 共享数据 在这个servlet中的保存的数据，可以在另外一个servlet中拿到。 通过ServletContext保存数据 package pizssn.servlet; import javax.servlet.ServletContext; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; public class ContextServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // this.getInitParameter() 初始化参数； // this.getServletConfig() servlet参数； // this.getServletContext() servlet上下文； ServletContext context = this.getServletContext(); String username = &quot;pizssn&quot;; /*数据*/ context.setAttribute(&quot;username&quot;, username); /*将一个数据保存在ServletContext中，名字为context*/ } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } 从ServletContext获取数据 package pizssn.servlet; import javax.servlet.ServletContext; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; public class GetServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { ServletContext context = this.getServletContext(); String username = (String) context.getAttribute(&quot;username&quot;); resp.setContentType(&quot;text/html&quot;); resp.setCharacterEncoding(&quot;utf-8&quot;); resp.getWriter().print(&quot;名字：&quot; + username); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } 获取初始化参数 在xml文件配置一些web应用初始化参数 &lt;context-param&gt; &lt;param-name&gt;url&lt;/param-name&gt; &lt;param-value&gt;jdbc:mysql://localhost:3306/mybaties&lt;/param-value&gt; &lt;/context-param&gt; 请求转发 A想拿到的资源只能从C拿到，但是A只能接触到B，B就去C找相应资源，再转给A 语法 ServletContext context = this.getServletContext(); // RequestDispatcher requestDispatcher = context.getRequestDispatcher(&quot;/SD1&quot;); // requestDispatcher.forward(req,resp); context.getRequestDispatcher(&quot;/SD1&quot;).forward(req,resp); 读取资源文件 Properties(需要一个文件流) 在java目录下新建Properties 在resources目录下新建Properties 两者都会被打包到同一个路径下：class（classpath） ","link":"https://pizssn.github.io/post/servletcontext-dui-xiang/"},{"title":"Servlet原理","content":"servlet是由服务器调用，web服务器在收到浏览器请求后一系列流程如下图所示 ","link":"https://pizssn.github.io/post/servlet-yuan-li/"},{"title":"Hello,Servlet——第一个servlet程序","content":"首先我们要先了解什么是servlet？ 狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。Servlet运行于支持Java的应用服务器中。从原理上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。 简单点说就是，servlet是Sun公司开发动态web的一门技术，Sun公司在这些API中提供了一个接口叫做：servlet。 那么，怎么开发一个servlet程序呢？ 只需要两个步骤： 编写一个类，实现servlet接口。 把开发好的Java类部署到Web服务器中。 构建Servlet servlet接口，Sun公司有两个默认的实现类：HTTPServlet，GenericServlet 构建一个普通的Maven项目 Maven环境优化 修改web.xml，使其版本为当下最新 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot; metadata-complete=&quot;true&quot;&gt; &lt;/web-app&gt; 将maven的结构搭建完整 编写一个servlet程序 编写一个普通类 public class HelloServlet{ } 实现servlet接口，这里直接继承HTTPServlet import java.io.PrintWriter; public class HelloServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(&quot;进入doGet方法！&quot;); PrintWriter writer = resp.getWriter(); /*相应流*/ writer.print(&quot;hello world!&quot;); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } 编写servlet的映射，我们写的Java程序，但是要通过浏览器访问，而浏览器需要连接web服务器。所以我们要在web服务器中注册我们的servlet，再为其设置一个浏览器能够访问的路径。 &lt;!--注册servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;servlet-class&gt;pizssn.servlet.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!--servlet的请求路径--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 配置Tomcat 启动测试 ","link":"https://pizssn.github.io/post/helloservlet-di-yi-ge-servlet-cheng-xu/"}]}
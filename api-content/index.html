{"posts":[{"title":"线程方法学习","content":" 列举了几个线程常用方法。 线程停止 建议线程正常停止，利用次数，不建议死循环 建议使用标志位，设置一个标志位 不要使用stop或者destroy等过时或JDK不建议使用的法 public class Demo1 implements Runnable { //设置一个标识位 private boolean flag = true; @Override public void run() { int i = 0; while (flag) { System.out.println(&quot;run...Thread&quot; + i++); } } //设置一个公开的方法停止线程，转换标志位 public void stop() { this.flag = false; } public static void main(String[] args) { Demo1 d = new Demo1(); new Thread(d).start(); for (int i = 0; i &lt; 10000; i++) { System.out.println(&quot;main&quot; + i); if (i == 9000) { //调用stop方法切换标志位，让线程停止 d.stop(); System.out.println(&quot;该线程停止&quot;); } } } } 线程休眠 sleep() 的作用是让当前线程休眠，即当前线程会从“运行状态”进入到“休眠(阻塞)状态”。sleep()会指定休眠时间，线程休眠的时间会大于/等于该休眠时间；在线程重新被唤醒时，它会由“阻塞状态”变成“就绪状态”，从而等待cpu的调度执行。 注意：sleep()和wait()是有区别的。wait()的作用是让当前线程由“运行状态”进入“等待(阻塞)状态”的同时，也会释放同步锁。而sleep()的作用是也是让当前线程由“运行状态”进入到“休眠(阻塞)状态”。但是，wait()会释放对象的同步锁，而sleep()则不会释放锁。 import java.text.SimpleDateFormat; import java.util.Date; //sleep的功能 public class Demo2 { public static void main(String[] args) throws InterruptedException { //打印当前系统时间 Date currentTime = new Date();//获取系统当前时间 while (true) { try { Thread.sleep(1000); System.out.println(new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(currentTime)); currentTime = new Date();//刷新系统当前时间 } catch (InterruptedException e) { e.printStackTrace(); } } } public static void TimeDown(int num) throws InterruptedException { //模拟倒计时的功能 while (true) { Thread.sleep(1000); System.out.println(num--); if (num &lt; 0) break; } } } 线程礼让 只是让原来已经执行的线程先退出来重新竞争资源，还是得看CPU分配。 public class Demo3 { public static void main(String[] args) { MyYield m = new MyYield(); new Thread(m, &quot;a&quot;).start(); new Thread(m, &quot;b&quot;).start(); new Thread(m, &quot;c&quot;).start(); } } class MyYield implements Runnable { @Override public void run() { System.out.println(Thread.currentThread().getName() + &quot;线程开始执行&quot;); Thread.yield();//线程礼让 System.out.println(Thread.currentThread().getName() + &quot;线程停止执行&quot;); } } 线程插队 使用join()方法，可实现&quot;插队&quot;效果。当插队的线程运行结束后，其他线程将继续执行。 public class Demo4 implements Runnable { @Override public void run() { for (int i = 0; i &lt; 100; i++) { System.out.println(&quot;线程VIP来了！&quot; + i); } } public static void main(String[] args) throws InterruptedException { //启动我们的线程 Demo4 j = new Demo4(); Thread thread = new Thread(j); thread.start(); //主线程 for (int i = 0; i &lt; 500; i++) { if (i == 200) { thread.join();//插队 } System.out.println(&quot;main&quot; + i); } } } 线程优先级 可以通过setPriority(优先级)方法设置线程的优先级，优先级从1~10。 注意：优先级高的不一定先行执行； //测试线程的优先级 public class Demo5 { public static void main(String[] args) { System.out.println(Thread.currentThread().getName() + &quot;----&quot; + Thread.currentThread().getPriority()); Mypriority mypriority = new Mypriority(); Thread t1 = new Thread(mypriority); Thread t2 = new Thread(mypriority); Thread t3 = new Thread(mypriority); Thread t4 = new Thread(mypriority); Thread t5 = new Thread(mypriority); Thread t6 = new Thread(mypriority); //先设置优先级，再启动 t1.start(); t2.setPriority(1); t2.start(); t3.setPriority(4); t3.start(); t4.setPriority(Thread.MAX_PRIORITY); t4.start(); t5.setPriority(3); t5.start(); t6.setPriority(10); t6.start(); } } class Mypriority implements Runnable { @Override public void run() { System.out.println(Thread.currentThread().getName() + &quot;----&quot; + Thread.currentThread().getPriority()); } } 守护线程 守护线程，在没有用户线程可服务时会自动离开。优先级：守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。 设置：通过setDaemon(true)来设置线程为“守护线程”；将一个用户线程设置为守护线程的方式是在线程对象创建之前，用线程对象的setDaemon方法。 thread.setDaemon(true);//默认是false，表示保护线程。正常的线程都是用户线程。 ","link":"https://pizssn.github.io/post/xian-cheng-fang-fa-xue-xi/"},{"title":"如何理解Lambda表达式","content":" Lambda 表达式（lambda expression）是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象（lambda abstraction），是一个匿名函数，即没有函数名的函数。Lambda表达式可以表示闭包。 这里就展示了Lambda是如何从其他表现形式一步步简化成为lambda表达式的，有助于对lambda表达式的理解与使用。 //1、先定义一个函数式借接口（就是只有一个抽象类方法） interface ILike { void Lombda(); } //2、实现类 class Like implements ILike { @Override public void Lombda() { System.out.println(&quot;i like lombda1!&quot;); } } public class Demo1 { //3、静态内部类 static class Like1 implements ILike { @Override public void Lombda() { System.out.println(&quot;i like lambda2!&quot;); } } public static void main(String[] args) { new Like().Lombda(); new Like1().Lombda(); //4、局部内部类 class Like2 implements ILike { @Override public void Lombda() { System.out.println(&quot;i like lambda3!&quot;); } } new Like2().Lombda(); //5、匿名内部类,没有类的名称，只能靠接口或者父类实现 ILike i = new ILike() { @Override public void Lombda() { System.out.println(&quot;i liek lambda4!&quot;); } }; i.Lombda(); //6、Lambda i = () -&gt; { System.out.println(&quot;i like lambda5!&quot;); }; i.Lombda(); } } ","link":"https://pizssn.github.io/post/ru-he-li-jie-lambda-biao-da-shi/"},{"title":"初识多线程","content":"什么是线程？ 线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。 什么是进程？ 进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。 回到今天的主题，多线程； 把多个任务分给多个线程,能提高其效率 单个线程 多个线程 实现多线程的三种方式 1. 继承Thread类，重写run()方法 Thread本质上也是实现了Runnable接口的一个实例，它代表了一个线程的实例，并且，启动线程的唯一方法就是通过Thread类的start()方法 //创建线程方式一；继承Thread类，重写run方法，调用start方法开启线程 //线程开启不一定立即执行，而是由CPU调度执行 public class Demo1 extends Thread{ @Override public void run() { for (int i=0;i&lt;10;i++) System.out.println(&quot;我在练习代码！&quot;+i); } //main线程，主线程 public static void main(String[] args) { //创建一个线程对象 Demo1 t = new Demo1(); //调用start方法开启线程 t.start(); for (int i=0;i&lt;2000;i++) System.out.println(&quot;我在看视频&quot;+i); } } 2. 实现Runnable接口，并实现run()方法 1）自定义类并实现Runnable接口，实现run()方法。 2）创建Thread对象，用实现Runnable接口的对象作为参数实例化该Thread对象 3）调用Thread的start()方法 //创建线程方法二：实现runnable接口，重写run方法，执行线程需要丢入runnable接口实现类，再调用start方法 public class Demo3 implements Runnable { public void run() { for (int i=0;i&lt;10;i++) System.out.println(&quot;我在练习代码！&quot;+i); } //main线程，主线程 public static void main(String[] args) { //创建一个线程对象 Demo3 t = new Demo3(); //Thread thread = new Thread(t); //thread.start(); new Thread(t).start(); for (int i=0;i&lt;20;i++) System.out.println(&quot;我在看视频&quot;+i); } } 3. 实现Callable接口，重写call()方法 1) 实现Callable接口，需要返回值类型 2) 重写call方法，需要抛出异常 3) 创建目标对象 4) 创建执行服务：ExecutorService ser = Executors.newFixedThreadPoll(1); 5) 提交执行：Future result = ser.submit(t); 6) 获取结果：boolean r = result.get(); 7) 关闭服务：ser.shutdownNow(); import java.util.concurrent.*; //线程创建方式三：实现Callable接口，重写call()方法 public class Demo4 implements Callable { @Override public Object call() throws Exception { for (int i=0;i&lt;10;i++) System.out.println(&quot;我在练习代码！&quot;+i); return true; } public static void main(String[] args) throws ExecutionException, InterruptedException { Demo4 t = new Demo4(); //创建执行服务 ExecutorService ser = Executors.newFixedThreadPool(2); //提交执行 Future&lt;Boolean&gt; r = ser.submit(t); for (int i=0;i&lt;2000;i++) System.out.println(&quot;我在看视频&quot;+i); //获取结果 boolean rs = r.get(); //关闭服务 ser.shutdown(); } } ","link":"https://pizssn.github.io/post/duo-xian-cheng/"},{"title":"Response重定向","content":" web资源B在收到客户端A请求后，B会通知A客户端去访问另外一个WEB资源C，这个过程即为重定向 语法 response.sendRedirect(&quot;/r/image&quot;); 请求转发和重定向的区别 相同点 页面都会发生跳转 不同点 请求转发的时候，URL不会发生变化，状态码：307 重定向的时候，URL会发生变化，状态码：302 ","link":"https://pizssn.github.io/post/response-chong-ding-xiang/"},{"title":"ServletContext对象","content":" web容器在启动的时候，它会为每个web程序都创建一个对应的ServletContext对象，他代表了当前的web应用。 共享数据 在这个servlet中的保存的数据，可以在另外一个servlet中拿到。 通过ServletContext保存数据 package pizssn.servlet; import javax.servlet.ServletContext; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; public class ContextServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // this.getInitParameter() 初始化参数； // this.getServletConfig() servlet参数； // this.getServletContext() servlet上下文； ServletContext context = this.getServletContext(); String username = &quot;pizssn&quot;; /*数据*/ context.setAttribute(&quot;username&quot;, username); /*将一个数据保存在ServletContext中，名字为context*/ } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } 从ServletContext获取数据 package pizssn.servlet; import javax.servlet.ServletContext; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; public class GetServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { ServletContext context = this.getServletContext(); String username = (String) context.getAttribute(&quot;username&quot;); resp.setContentType(&quot;text/html&quot;); resp.setCharacterEncoding(&quot;utf-8&quot;); resp.getWriter().print(&quot;名字：&quot; + username); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } 获取初始化参数 在xml文件配置一些web应用初始化参数 &lt;context-param&gt; &lt;param-name&gt;url&lt;/param-name&gt; &lt;param-value&gt;jdbc:mysql://localhost:3306/mybaties&lt;/param-value&gt; &lt;/context-param&gt; 请求转发 A想拿到的资源只能从C拿到，但是A只能接触到B，B就去C找相应资源，再转给A 语法 ServletContext context = this.getServletContext(); // RequestDispatcher requestDispatcher = context.getRequestDispatcher(&quot;/SD1&quot;); // requestDispatcher.forward(req,resp); context.getRequestDispatcher(&quot;/SD1&quot;).forward(req,resp); 读取资源文件 Properties(需要一个文件流) 在java目录下新建Properties 在resources目录下新建Properties 两者都会被打包到同一个路径下：class（classpath） ","link":"https://pizssn.github.io/post/servletcontext-dui-xiang/"},{"title":"Servlet原理","content":"servlet是由服务器调用，web服务器在收到浏览器请求后一系列流程如下图所示 ","link":"https://pizssn.github.io/post/servlet-yuan-li/"},{"title":"Hello,Servlet——第一个servlet程序","content":"首先我们要先了解什么是servlet？ 狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。Servlet运行于支持Java的应用服务器中。从原理上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。 简单点说就是，servlet是Sun公司开发动态web的一门技术，Sun公司在这些API中提供了一个接口叫做：servlet。 那么，怎么开发一个servlet程序呢？ 只需要两个步骤： 编写一个类，实现servlet接口。 把开发好的Java类部署到Web服务器中。 构建Servlet servlet接口，Sun公司有两个默认的实现类：HTTPServlet，GenericServlet 构建一个普通的Maven项目 Maven环境优化 修改web.xml，使其版本为当下最新 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot; metadata-complete=&quot;true&quot;&gt; &lt;/web-app&gt; 将maven的结构搭建完整 编写一个servlet程序 编写一个普通类 public class HelloServlet{ } 实现servlet接口，这里直接继承HTTPServlet import java.io.PrintWriter; public class HelloServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(&quot;进入doGet方法！&quot;); PrintWriter writer = resp.getWriter(); /*相应流*/ writer.print(&quot;hello world!&quot;); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } 编写servlet的映射，我们写的Java程序，但是要通过浏览器访问，而浏览器需要连接web服务器。所以我们要在web服务器中注册我们的servlet，再为其设置一个浏览器能够访问的路径。 &lt;!--注册servlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;servlet-class&gt;pizssn.servlet.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!--servlet的请求路径--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;hello&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 配置Tomcat 启动测试 ","link":"https://pizssn.github.io/post/helloservlet-di-yi-ge-servlet-cheng-xu/"}]}